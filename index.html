<!DOCTYPE html>
<html lang="en">
<head>
    <title>Game of Grids - Power Infrastructure Mapping</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Collaborative power infrastructure mapping using OpenStreetMap and JOSM">
    <meta name="theme-color" content="#036d7a">
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚ö°</text></svg>">
</head>
<body>
    <!-- Toast notifications -->
    <div id="toastContainer" class="toast-container"></div>
    
    <!-- Loading overlay -->
    <div id="loadingOverlay" class="loading-overlay">
        <div class="loading-spinner">‚ö°</div>
        <div class="loading-text">Loading patches...</div>
    </div>
    
    <!-- Theme toggle -->
    <button id="themeToggle" class="theme-toggle" title="Toggle dark mode" aria-label="Toggle dark mode">
        <span class="theme-icon">üåô</span>
    </button>
    
    <!-- Connection status -->
    <div class="connection-status" id="connectionStatus" role="status" aria-live="polite">
        üåê Connecting...
    </div>
    
    <div class="container">
        <header class="header">
            <h1>‚ö° Game of Grids</h1>
            <p>Automated Power Infrastructure Mapping with OpenStreetMap & JOSM</p>
        </header>
        
        <!-- Prerequisites -->
        <section class="warning" role="region" aria-labelledby="prerequisites-heading">
            <h2 id="prerequisites-heading">üîß Prerequisites</h2>
            <div class="feature-grid">
                <div class="feature-item">
                    <span class="feature-icon">‚úÖ</span>
                    <div>
                        <strong>JOSM Editor</strong>
                        <p>Running with remote control enabled</p>
                    </div>
                </div>
                <div class="feature-item">
                    <span class="feature-icon">üåê</span>
                    <div>
                        <strong>Internet Connection</strong>
                        <p>Stable connection required</p>
                    </div>
                </div>
                <div class="feature-item">
                    <span class="feature-icon">üîç</span>
                    <div>
                        <strong>Remote Control</strong>
                        <p>Edit ‚Üí Preferences ‚Üí Remote Control</p>
                    </div>
                </div>
                <div class="feature-item">
                    <span class="feature-icon">üî®</span>
                    <div>
                        <strong>Create New Objects</strong>
                        <p>Enable in Remote Control permissions</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Workflow -->
        <section class="info" role="region" aria-labelledby="workflow-heading">
            <h2 id="workflow-heading">üö® Mapping Workflow</h2>
            <div class="workflow-steps">
                <div class="workflow-step">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <h3>üéØ Load Data</h3>
                        <p><strong>2 Layers:</strong> Boundary+Notes ‚Üí Power (active) ‚Üí Auto-zoom to boundary</p>
                    </div>
                </div>
                <div class="workflow-step">
                    <div class="step-number">2</div>
                    <div class="step-content">
                        <h3>üó∫Ô∏è Map Infrastructure</h3>
                        <p>Add missing power features within the boundary area</p>
                    </div>
                </div>
                <div class="workflow-step">
                    <div class="step-number">3</div>
                    <div class="step-content">
                        <h3>üíæ Upload Changes</h3>
                        <p>Upload only the power layer (boundary/notes are reference only)</p>
                    </div>
                </div>
                <div class="workflow-step">
                    <div class="step-number">4</div>
                    <div class="step-content">
                        <h3>‚úÖ Mark Complete</h3>
                        <p>Submit completion to track mapping progress</p>
                    </div>
                </div>
            </div>
        </section>
        
        <!-- Mapping targets -->
        <section class="info" role="region" aria-labelledby="targets-heading">
            <h2 id="targets-heading">üéØ Power Infrastructure to Map</h2>
            <div class="feature-grid">
                <div class="feature-item">
                    <span class="feature-icon">‚ö°</span>
                    <div>
                        <strong>Power Lines</strong>
                        <p>All power lines & cables</p>
                    </div>
                </div>
                <div class="feature-item">
                    <span class="feature-icon">üóº</span>
                    <div>
                        <strong>Support Structures</strong>
                        <p>Towers, poles, portals & terminals</p>
                    </div>
                </div>
                <div class="feature-item">
                    <span class="feature-icon">üè≠</span>
                    <div>
                        <strong>Facilities</strong>
                        <p>Substations, transformers, plants & generators</p>
                    </div>
                </div>
                <div class="feature-item">
                    <span class="feature-icon">‚òÄÔ∏è</span>
                    <div>
                        <strong>Renewables</strong>
                        <p>Solar panels & wind turbines</p>
                    </div>
                </div>
                <div class="feature-item">
                    <span class="feature-icon">üìù</span>
                    <div>
                        <strong>OSM Notes</strong>
                        <p>Reference information & user reports</p>
                    </div>
                </div>
            </div>
        </section>
        
        <!-- Controls -->
        <section class="controls" role="region" aria-labelledby="controls-heading">
            <h2 id="controls-heading" class="sr-only">Application Controls</h2>
            <div class="controls-grid">
                <div class="control-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="showCompleted" onchange="loadPatches()">
                        <span class="checkmark"></span>
                        <span>Show completed patches</span>
                    </label>
                </div>
                
                <div class="control-group">
                    <label for="countryCode" class="control-label">Country Code:</label>
                    <div class="input-with-validation">
                        <input 
                            type="text" 
                            id="countryCode" 
                            value="KZ" 
                            maxlength="2" 
                            pattern="[A-Z]{2}" 
                            onchange="validateAndLoadPatches()" 
                            oninput="this.value = this.value.toUpperCase()"
                            placeholder="e.g. KZ"
                        >
                        <div class="validation-message" id="countryValidation"></div>
                    </div>
                </div>
                
                <div class="action-buttons">
                    <button onclick="loadPatches()" class="button refresh-button">
                        üîÑ <span>Refresh</span>
                    </button>
                    <button onclick="testJOSMButton()" class="button test-button">
                        üß™ <span>Test JOSM</span>
                    </button>
                    <button onclick="testOverpass()" class="button overpass-button">
                        üåê <span>Test Overpass</span>
                    </button>
                    <button onclick="debugDatabase()" class="button debug-button">
                        üîç <span>Debug</span>
                    </button>
                </div>
            </div>
        </section>
        
        <!-- Stats and progress -->
        <div id="stats" class="stats" role="status" aria-live="polite"></div>
        <div id="progressLog" class="progress-log" role="log" aria-live="polite"></div>
        
        <!-- Main content -->
        <main class="grid" role="main">
            <div class="cards-container" id="patches" aria-live="polite" aria-label="Available mapping patches">
                <!-- Patches rendered here -->
            </div>
        </main>
        
        <!-- Keyboard shortcuts help -->
        <div id="keyboardHelp" class="keyboard-help" style="display: none;">
            <h3>‚å®Ô∏è Keyboard Shortcuts</h3>
            <div class="shortcut-list">
                <div class="shortcut-item"><kbd>Esc</kbd> Close expanded patch</div>
                <div class="shortcut-item"><kbd>R</kbd> Refresh patches</div>
                <div class="shortcut-item"><kbd>T</kbd> Test JOSM</div>
                <div class="shortcut-item"><kbd>Ctrl+D</kbd> Toggle dark mode</div>
                <div class="shortcut-item"><kbd>?</kbd> Toggle this help</div>
            </div>
        </div>
    </div>
    
    <!-- Patch overlay -->
    <div class="patch-overlay" id="patchOverlay" onclick="closeAllPatches()" onkeydown="if(event.key==='Escape' || event.key==='Enter') closeAllPatches()" role="button" tabindex="0" aria-label="Close expanded patch"></div>
    
    <script>
        'use strict';
        
        // Configuration
        const CONFIG = {
            SUPABASE_URL: 'https://teumppdbhbrozswbpond.supabase.co/rest/v1',
            SUPABASE_KEY: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRldW1wcGRiaGJyb3pzd2Jwb25kIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTAyMjY2MDYsImV4cCI6MjA2NTgwMjYwNn0.8j2yv4SuZJXnHV_spPIQQGsPBrvZrmYld6IlT7Omu7E',
            JOSM_BASE_URL: 'http://localhost:8111',
            JOSM_TIMEOUT: 30000,
            OVERPASS_TIMEOUT: 180000,
            REFRESH_INTERVAL: 300000,
            MAX_RETRIES: 3,
            PAGINATION_SIZE: 50,
            APP_VERSION: '2.2.0'
        };
        
        // Application state
        const AppState = {
            currentPatches: [],
            isLoading: false,
            connectionStatus: 'connecting',
            theme: localStorage.getItem('theme') || 'light',
            lastRefresh: Date.now()
        };

        // Toast notification system
        class ToastManager {
            constructor() {
                this.container = document.getElementById('toastContainer');
            }
            
            show(message, type = 'info', duration = 5000) {
                const toast = document.createElement('div');
                toast.className = `toast toast-${type}`;
                toast.setAttribute('role', 'alert');
                
                const icons = { success: '‚úÖ', error: '‚ùå', warning: '‚ö†Ô∏è', info: '‚ÑπÔ∏è' };
                toast.innerHTML = `
                    <div class="toast-content">
                        <span class="toast-icon">${icons[type] || '‚ÑπÔ∏è'}</span>
                        <span class="toast-message">${message}</span>
                        <button class="toast-close" onclick="this.parentElement.parentElement.remove()">√ó</button>
                    </div>
                `;
                
                this.container.appendChild(toast);
                if (duration > 0) setTimeout(() => toast.remove(), duration);
            }
        }
        
        const toast = new ToastManager();

        // Theme management
        class ThemeManager {
            constructor() {
                this.applyTheme(AppState.theme);
                this.updateToggleButton();
            }
            
            toggle() {
                AppState.theme = AppState.theme === 'light' ? 'dark' : 'light';
                this.applyTheme(AppState.theme);
                localStorage.setItem('theme', AppState.theme);
                this.updateToggleButton();
            }
            
            applyTheme(theme) {
                document.documentElement.setAttribute('data-theme', theme);
            }
            
            updateToggleButton() {
                const button = document.getElementById('themeToggle');
                const icon = button.querySelector('.theme-icon');
                icon.textContent = AppState.theme === 'light' ? 'üåô' : '‚òÄÔ∏è';
            }
        }
        
        const themeManager = new ThemeManager();

        // Utility functions
        function logProgress(message, type = 'info') {
            const log = document.getElementById('progressLog');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.innerHTML = `
                <span class="log-timestamp">[${new Date().toLocaleTimeString()}]</span>
                <span class="log-message">${message}</span>
            `;
            
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
            
            const entries = log.querySelectorAll('.log-entry');
            if (entries.length > 50) entries[0].remove();
            
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function logProgressForPatch(patchId, message, type = 'info') {
            const log = document.getElementById(`progressLog-${patchId}`);
            if (!log) return;
            
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.innerHTML = `
                <span class="log-timestamp">[${new Date().toLocaleTimeString()}]</span>
                <span class="log-message">${message}</span>
            `;
            
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
            log.classList.add('active');
            
            console.log(`[${type.toUpperCase()}] Patch ${patchId}: ${message}`);
        }

        function showProgressIndicator(text = 'Loading...') {
            const overlay = document.getElementById('loadingOverlay');
            overlay.querySelector('.loading-text').textContent = text;
            overlay.classList.add('active');
        }

        function hideProgressIndicator() {
            document.getElementById('loadingOverlay').classList.remove('active');
        }

        // Database functions
        function getSupabaseHeaders() {
            return {
                'apikey': CONFIG.SUPABASE_KEY,
                'Authorization': `Bearer ${CONFIG.SUPABASE_KEY}`,
                'Content-Type': 'application/json',
                'Prefer': 'return=representation'
            };
        }

        async function supabaseQuery(endpoint, options = {}) {
            const url = `${CONFIG.SUPABASE_URL}${endpoint}`;
            
            for (let attempt = 1; attempt <= CONFIG.MAX_RETRIES; attempt++) {
                try {
                    const response = await fetch(url, {
                        ...options,
                        headers: { ...getSupabaseHeaders(), ...options.headers }
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Database error: ${response.status} ${response.statusText}`);
                    }
                    
                    return await response.json();
                } catch (error) {
                    if (attempt === CONFIG.MAX_RETRIES) throw error;
                    await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                }
            }
        }

        // Connection status
        function updateConnectionStatus(online, message = '') {
            const status = document.getElementById('connectionStatus');
            AppState.connectionStatus = online ? 'online' : 'offline';
            
            if (online) {
                status.className = 'connection-status connection-online';
                status.textContent = 'üåê Online';
            } else {
                status.className = 'connection-status connection-offline';
                status.textContent = `‚ùå ${message || 'Offline'}`;
            }
        }

        async function testConnection() {
            try {
                await supabaseQuery('/osmose_patches?select=count&limit=1');
                updateConnectionStatus(true);
                return true;
            } catch (error) {
                updateConnectionStatus(false, 'DB Error');
                console.error('Database connection failed:', error);
                return false;
            }
        }

        // Validation
        function validateCountryCode(code) {
            const trimmed = code.trim().toUpperCase();
            const isValid = /^[A-Z]{2}$/.test(trimmed);
            
            const validation = document.getElementById('countryValidation');
            if (!isValid && trimmed.length > 0) {
                validation.textContent = 'Please enter a valid 2-letter country code';
                validation.className = 'validation-message error';
                return false;
            } else {
                validation.textContent = '';
                validation.className = 'validation-message';
                return true;
            }
        }

        function validateAndLoadPatches() {
            const countryCode = document.getElementById('countryCode').value;
            if (validateCountryCode(countryCode)) loadPatches();
        }
        
        function setLoading(loading) {
            AppState.isLoading = loading;
            const patches = document.getElementById('patches');
            
            if (loading) {
                patches.classList.add('loading');
                showProgressIndicator('Loading patches...');
            } else {
                patches.classList.remove('loading');
                hideProgressIndicator();
            }
        }
        
        // Patch loading
        async function loadPatches() {
            if (AppState.isLoading) return;
            
            setLoading(true);
            const showCompleted = document.getElementById('showCompleted').checked;
            const countryCode = document.getElementById('countryCode').value.toUpperCase() || 'KZ';
            
            if (!validateCountryCode(countryCode)) {
                setLoading(false);
                return;
            }
            
            try {
                logProgress(`Loading patches for ${countryCode}...`, 'info');
                
                const connected = await testConnection();
                if (!connected) throw new Error('Database connection failed');

                const query = `/osmose_patches?select=patch_id,country_code,country_name,error_count,area_km2,perimeter_km,priority,difficulty,created_at&country_code=eq.${countryCode}&order=priority.desc,created_at.asc&limit=${CONFIG.PAGINATION_SIZE}`;
                const patches = await supabaseQuery(query);
                
                logProgress(`Found ${patches.length} patches in database`, 'success');
                
                let filteredPatches = patches;
                if (!showCompleted) {
                    const completedQuery = `/patch_assignments?select=patch_id&status=eq.completed`;
                    const completedPatches = await supabaseQuery(completedQuery);
                    const completedIds = new Set(completedPatches.map(p => p.patch_id));
                    
                    filteredPatches = patches.filter(p => !completedIds.has(p.patch_id));
                    logProgress(`Filtered to ${filteredPatches.length} incomplete patches`, 'info');
                }
                
                AppState.currentPatches = filteredPatches;
                
                // Get completion status for remaining patches
                const patchIds = AppState.currentPatches.map(p => p.patch_id);
                if (patchIds.length > 0) {
                    const statusQuery = `/patch_assignments?select=patch_id,status&patch_id=in.(${patchIds.join(',')})&status=eq.completed`;
                    const completedStatuses = await supabaseQuery(statusQuery);
                    const completedMap = new Map(completedStatuses.map(s => [s.patch_id, s.status]));
                    
                    AppState.currentPatches.forEach(patch => {
                        patch.status = completedMap.get(patch.patch_id) || 'available';
                    });
                }
                
                renderPatches(AppState.currentPatches);
                AppState.lastRefresh = Date.now();
                
                toast.show(`Loaded ${AppState.currentPatches.length} patches for ${countryCode}`, 'success');
                
            } catch (error) {
                console.error('Error loading patches:', error);
                logProgress(`Error: ${error.message}`, 'error');
                updateConnectionStatus(false, 'Load Error');
                
                document.getElementById('patches').innerHTML = 
                    `<div class="error-state">
                        <div class="error-icon">‚ùå</div>
                        <h3>Error loading patches</h3>
                        <p>${error.message}</p>
                        <button onclick="loadPatches()" class="button refresh-button">üîÑ Try Again</button>
                    </div>`;
                
                toast.show(`Failed to load patches: ${error.message}`, 'error');
            } finally {
                setLoading(false);
            }
        }
        
        // Patch rendering
        function renderPatches(patches) {
            const container = document.getElementById('patches');
            
            if (patches.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üîç</div>
                        <h3>No patches found</h3>
                        <p>Try a different country code or enable "Show completed patches"</p>
                        <button onclick="loadPatches()" class="button refresh-button">üîÑ Refresh</button>
                    </div>`;
                return;
            }
            
            const countryCode = document.getElementById('countryCode').value.toUpperCase() || 'KZ';
            const completedCount = patches.filter(p => p.status === 'completed').length;
            const availableCount = patches.length - completedCount;
            
            document.getElementById('stats').innerHTML = 
                `üìä Showing <strong>${patches.length}</strong> patches for <strong>${countryCode}</strong> 
                 ‚Ä¢ <span class="stat-available">${availableCount} available</span> 
                 ‚Ä¢ <span class="stat-completed">${completedCount} completed</span>`;
            
            container.innerHTML = patches.map(patch => createPatchHTML(patch)).join('');
        }

        function createPatchHTML(patch) {
            const statusClass = patch.status === 'completed' ? 'completed' : '';
            const difficultyClass = patch.difficulty ? `difficulty-${patch.difficulty.toLowerCase()}` : 'difficulty-medium';
            
            return `
                <article class="patch ${statusClass} ${difficultyClass}" id="patch-${patch.patch_id}" 
                         tabindex="0" role="button" 
                         onclick="togglePatchExpansion('${patch.patch_id}')"
                         onkeydown="handlePatchKeydown(event, '${patch.patch_id}')"
                         aria-expanded="false">
                    
                    <div class="status-badge ${patch.status === 'completed' ? 'completed-badge' : 'available'}">
                        ${patch.status.toUpperCase()}
                    </div>
                    
                    <header class="patch-header">
                        <h3>üó∫Ô∏è Patch ${patch.patch_id}</h3>
                        <div class="patch-meta">
                            <span class="patch-country">${patch.country_name || patch.country_code}</span>
                            <span class="patch-date">${new Date(patch.created_at).toLocaleDateString()}</span>
                        </div>
                    </header>
                    
                    <div class="patch-summary">
                        ${patch.status === 'completed' ? 
                            '<div class="completion-indicator">‚úÖ Mapping completed</div>' :
                            '<div class="action-hint">üöÄ Start Mapping</div>'
                        }
                    </div>
                    
                    <!-- Expanded Content -->
                    <div class="patch-expanded-content" onclick="event.stopPropagation()">
                        <div class="expanded-inner">
                            <header class="expanded-header">
                                <h4>üó∫Ô∏è Patch ${patch.patch_id} Details</h4>
                                <button class="close-button-header" onclick="closePatchExpansion('${patch.patch_id}'); event.stopPropagation();">√ó</button>
                            </header>
                            
                            <div class="form-sections">
                                <section class="form-section">
                                    <h5>üë§ Mapper Information</h5>
                                    <div class="form-row">
                                        <div class="form-group">
                                            <label for="mapperId-${patch.patch_id}">OpenStreetMap Username *</label>
                                            <input type="text" id="mapperId-${patch.patch_id}" required placeholder="Your OSM username">
                                        </div>
                                        <div class="form-group">
                                            <label for="mapperEmail-${patch.patch_id}">Email (Optional)</label>
                                            <input type="email" id="mapperEmail-${patch.patch_id}" placeholder="your@email.com">
                                        </div>
                                    </div>
                                </section>
                                
                                <section class="form-section">
                                    <h5>üìù Completion Notes</h5>
                                    <div class="form-group">
                                        <label for="mappingNotes-${patch.patch_id}">Notes about your mapping work (Optional)</label>
                                        <textarea id="mappingNotes-${patch.patch_id}" placeholder="Add notes about features found, issues encountered, or other relevant information..."></textarea>
                                    </div>
                                </section>
                            </div>
                            
                            <div class="action-buttons">
                                <button class="button load-button" onclick="loadPatchInJOSM('${patch.patch_id}', this); event.stopPropagation();">
                                    üöÄ <span>Load in JOSM</span>
                                </button>
                                <button class="button complete-button" onclick="markPatchComplete('${patch.patch_id}'); event.stopPropagation();">
                                    ‚úÖ <span>Mark Complete</span>
                                </button>
                                <button class="button overpass-button" onclick="openOverpassLink('${patch.patch_id}'); event.stopPropagation();">
                                    üåê <span>Open in Overpass</span>
                                </button>
                                <button class="close-button" onclick="closePatchExpansion('${patch.patch_id}'); event.stopPropagation();">
                                    ‚úï <span>Close</span>
                                </button>
                            </div>
                            
                            <div id="progressLog-${patch.patch_id}" class="progress-log" role="log" aria-live="polite"></div>
                        </div>
                    </div>
                </article>
            `;
        }

        // Patch expansion
        function handlePatchKeydown(event, patchId) {
            if (event.key === 'Enter') {
                event.preventDefault();
                togglePatchExpansion(patchId);
            }
        }

        function togglePatchExpansion(patchId) {
            const patchElement = document.getElementById(`patch-${patchId}`);
            const overlay = document.getElementById('patchOverlay');
            
            if (!patchElement) return;
            
            const isExpanded = patchElement.classList.contains('expanded');
            closeAllPatches();
            
            if (!isExpanded) {
                patchElement.classList.add('expanded');
                patchElement.setAttribute('aria-expanded', 'true');
                overlay.classList.add('active');
                document.body.style.overflow = 'hidden';
                
                setTimeout(() => {
                    const firstInput = patchElement.querySelector('input[type="text"]');
                    if (firstInput) firstInput.focus();
                }, 100);
                
                logProgress(`Opened patch ${patchId} for editing`, 'info');
            }
        }
        
        function closePatchExpansion(patchId) {
            const patchElement = document.getElementById(`patch-${patchId}`);
            const overlay = document.getElementById('patchOverlay');
            
            if (patchElement) {
                patchElement.classList.remove('expanded');
                patchElement.setAttribute('aria-expanded', 'false');
                patchElement.focus();
            }
            overlay.classList.remove('active');
            document.body.style.overflow = '';
        }
        
        function closeAllPatches() {
            const overlay = document.getElementById('patchOverlay');
            document.querySelectorAll('.patch.expanded').forEach(patch => {
                patch.classList.remove('expanded');
                patch.setAttribute('aria-expanded', 'false');
            });
            overlay.classList.remove('active');
            document.body.style.overflow = '';
        }

        // Get patch details
        async function getPatchDetails(patchId) {
            try {
                logProgressForPatch(patchId, 'Fetching patch geometry...', 'info');
                
                const patches = await supabaseQuery(`/osmose_patches?select=*&patch_id=eq.${patchId}&limit=1`);
                if (patches.length === 0) throw new Error('Patch not found in database');
                
                const patch = patches[0];
                let bbox;
                
                if (patch.geometry) {
                    try {
                        const geom = typeof patch.geometry === 'string' ? JSON.parse(patch.geometry) : patch.geometry;
                        
                        if (geom?.coordinates) {
                            let allCoords = [];
                            if (geom.type === 'Polygon') {
                                allCoords = geom.coordinates[0];
                            } else if (geom.type === 'MultiPolygon') {
                                allCoords = geom.coordinates.flat(2);
                            }
                            
                            if (allCoords.length > 0) {
                                const lons = allCoords.map(coord => coord[0]);
                                const lats = allCoords.map(coord => coord[1]);
                                
                                bbox = {
                                    min_lat: Math.min(...lats),
                                    min_lon: Math.min(...lons),
                                    max_lat: Math.max(...lats),
                                    max_lon: Math.max(...lons)
                                };
                                
                                logProgressForPatch(patchId, 'Geometry parsed successfully', 'success');
                            }
                        }
                    } catch (geomError) {
                        logProgressForPatch(patchId, `Geometry parsing warning: ${geomError.message}`, 'warning');
                    }
                }
                
                if (!bbox) {
                    logProgressForPatch(patchId, 'Using fallback coordinates', 'warning');
                    bbox = { min_lat: 48.0, min_lon: 67.0, max_lat: 48.02, max_lon: 67.02 };
                }
                
                // Add padding for mapping context
                const padding = 0.002;
                bbox.min_lat -= padding;
                bbox.min_lon -= padding;
                bbox.max_lat += padding;
                bbox.max_lon += padding;
                
                return { ...patch, bbox };
                
            } catch (error) {
                logProgressForPatch(patchId, `Error getting patch details: ${error.message}`, 'error');
                throw error;
            }
        }
        
        // Create OSM XML for boundary rectangle
        function createBoundaryOSMXML(bbox, patchId) {
            const nodes = [
                { id: -1, lat: bbox.min_lat, lon: bbox.min_lon }, // Bottom-left
                { id: -2, lat: bbox.min_lat, lon: bbox.max_lon }, // Bottom-right  
                { id: -3, lat: bbox.max_lat, lon: bbox.max_lon }, // Top-right
                { id: -4, lat: bbox.max_lat, lon: bbox.min_lon }  // Top-left
            ];
            
            return `<?xml version="1.0" encoding="UTF-8"?>
<osm version="0.6" generator="Game of Grids">
${nodes.map(node => 
    `  <node id="${node.id}" lat="${node.lat.toFixed(7)}" lon="${node.lon.toFixed(7)}" version="1">
    <tag k="note" v="Patch ${patchId} boundary corner - DO NOT UPLOAD"/>
  </node>`
).join('\n')}
  <way id="-5" version="1">
${nodes.map(node => `    <nd ref="${node.id}"/>`).join('\n')}
    <nd ref="-1"/>
    <tag k="boundary" v="patch"/>
    <tag k="name" v="Patch ${patchId} Boundary"/>
    <tag k="note" v="Visual boundary only - DO NOT UPLOAD TO OSM"/>
    <tag k="fixme" v="This is a mapping boundary marker, not real OSM data"/>
  </way>
</osm>`;
        }

        // Create Overpass query for power infrastructure
        function createOverpassQuery(bbox) {
            return `[out:xml][timeout:180];
(
  node["power"="tower"](${bbox.min_lat},${bbox.min_lon},${bbox.max_lat},${bbox.max_lon});
  node["power"="pole"](${bbox.min_lat},${bbox.min_lon},${bbox.max_lat},${bbox.max_lon});
  node["power"="portal"](${bbox.min_lat},${bbox.min_lon},${bbox.max_lat},${bbox.max_lon});
  way["power"="line"](${bbox.min_lat},${bbox.min_lon},${bbox.max_lat},${bbox.max_lon});
  way["power"="cable"](${bbox.min_lat},${bbox.min_lon},${bbox.max_lat},${bbox.max_lon});
  node["power"="substation"](${bbox.min_lat},${bbox.min_lon},${bbox.max_lat},${bbox.max_lon});
  way["power"="substation"](${bbox.min_lat},${bbox.min_lon},${bbox.max_lat},${bbox.max_lon});
  relation["power"="substation"](${bbox.min_lat},${bbox.min_lon},${bbox.max_lat},${bbox.max_lon});
  node["power"="plant"](${bbox.min_lat},${bbox.min_lon},${bbox.max_lat},${bbox.max_lon});
  way["power"="plant"](${bbox.min_lat},${bbox.min_lon},${bbox.max_lat},${bbox.max_lon});
  relation["power"="plant"](${bbox.min_lat},${bbox.min_lon},${bbox.max_lat},${bbox.max_lon});
  node["power"="generator"](${bbox.min_lat},${bbox.min_lon},${bbox.max_lat},${bbox.max_lon});
  way["power"="generator"](${bbox.min_lat},${bbox.min_lon},${bbox.max_lat},${bbox.max_lon});
  relation["power"="generator"](${bbox.min_lat},${bbox.min_lon},${bbox.max_lat},${bbox.max_lon});
  node["power"="transformer"](${bbox.min_lat},${bbox.min_lon},${bbox.max_lat},${bbox.max_lon});
  way["power"="transformer"](${bbox.min_lat},${bbox.min_lon},${bbox.max_lat},${bbox.max_lon});
  relation["power"="transformer"](${bbox.min_lat},${bbox.min_lon},${bbox.max_lat},${bbox.max_lon});
  node["construction:power"](${bbox.min_lat},${bbox.min_lon},${bbox.max_lat},${bbox.max_lon});
  way["construction:power"](${bbox.min_lat},${bbox.min_lon},${bbox.max_lat},${bbox.max_lon});
  relation["construction:power"](${bbox.min_lat},${bbox.min_lon},${bbox.max_lat},${bbox.max_lon});
);
out meta;
>;
out meta qt;`;
        }

        // Load power infrastructure from Overpass
        async function loadOverpassDataInJOSM(bbox, patchId) {
            const overpassQL = createOverpassQuery(bbox);
            const overpassUrl = 'https://overpass-api.de/api/interpreter?' + 
                new URLSearchParams({ data: overpassQL }).toString();

            const josmImportUrl = `${CONFIG.JOSM_BASE_URL}/import?` +
                new URLSearchParams({
                    new_layer: 'true',
                    layer_name: `Patch ${patchId} - Power Infrastructure`
                }).toString() + '&url=' + encodeURIComponent(overpassUrl);

            logProgressForPatch(patchId, 'Loading power infrastructure from Overpass...', 'info');

            try {
                const importResponse = await fetch(josmImportUrl, {
                    method: 'GET',
                    signal: AbortSignal.timeout(CONFIG.OVERPASS_TIMEOUT)
                });
                
                if (!importResponse.ok) {
                    throw new Error(`JOSM import failed (HTTP ${importResponse.status})`);
                }
                
                logProgressForPatch(patchId, '‚úì Power infrastructure loaded', 'success');
                return true;

            } catch (err) {
                logProgressForPatch(patchId, `‚ö†Ô∏è Overpass import failed: ${err.message}`, 'warning');
                return false;
            }
        }

        // Convert OSM Notes to XML
        function convertNotesToOSMXML(notes, patchId) {
            let nodeId = -1000;
            let xmlContent = `<?xml version="1.0" encoding="UTF-8"?>\n<osm version="0.6" generator="Game of Grids">\n`;

            notes.forEach(note => {
                const coords = note.geometry.coordinates; // [lon, lat]
                const props = note.properties;
                
                xmlContent += `  <node id="${nodeId}" lat="${coords[1].toFixed(7)}" lon="${coords[0].toFixed(7)}" version="1">\n`;
                xmlContent += `    <tag k="note:id" v="${props.id}"/>\n`;
                xmlContent += `    <tag k="note:status" v="${props.status}"/>\n`;
                xmlContent += `    <tag k="note:date_created" v="${props.date_created}"/>\n`;
                
                if (props.closed_at) {
                    xmlContent += `    <tag k="note:closed_at" v="${props.closed_at}"/>\n`;
                }
                
                // Add the first comment as the main note text
                if (props.comments && props.comments.length > 0) {
                    const firstComment = props.comments[0];
                    const escapedText = (firstComment.text || '')
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&apos;');
                    
                    xmlContent += `    <tag k="note:comment" v="${escapedText}"/>\n`;
                    xmlContent += `    <tag k="note:user" v="${firstComment.user || 'Anonymous'}"/>\n`;
                    xmlContent += `    <tag k="note:action" v="${firstComment.action}"/>\n`;
                    
                    if (firstComment.date) {
                        xmlContent += `    <tag k="note:comment_date" v="${firstComment.date}"/>\n`;
                    }
                }
                
                xmlContent += `    <tag k="source" v="OSM Notes API"/>\n`;
                xmlContent += `    <tag k="fixme" v="OSM Note - Do not upload as OSM data"/>\n`;
                xmlContent += `  </node>\n`;
                
                nodeId--;
            });

            xmlContent += `</osm>`;
            return xmlContent;
        }

        // Merge boundary and notes XML
        function mergeBoundaryAndNotesXML(boundaryXML, notesXML) {
            try {
                const extractContent = (xmlString) => {
                    const osmStart = xmlString.indexOf('<osm');
                    const osmTagEnd = xmlString.indexOf('>', osmStart) + 1;
                    const osmEnd = xmlString.lastIndexOf('</osm>');
                    return xmlString.substring(osmTagEnd, osmEnd).trim();
                };

                const boundaryContent = extractContent(boundaryXML);
                const notesContent = extractContent(notesXML);

                return `<?xml version="1.0" encoding="UTF-8"?>
<osm version="0.6" generator="Game of Grids">
${boundaryContent}
${notesContent}
</osm>`;
                
            } catch (error) {
                console.error('XML merge error:', error);
                return boundaryXML; // Fallback
            }
        }

        // Load merged boundary and notes layer
        async function loadMergedBoundaryAndNotesInJOSM(bbox, notes, patchId) {
            logProgressForPatch(patchId, 'Creating combined boundary & notes layer...', 'info');

            try {
                const boundaryXML = createBoundaryOSMXML(bbox, patchId);
                let combinedXML;

                if (notes.length > 0) {
                    const notesXML = convertNotesToOSMXML(notes, patchId);
                    combinedXML = mergeBoundaryAndNotesXML(boundaryXML, notesXML);
                    logProgressForPatch(patchId, `Merged XML created (${notes.length} notes + boundary)`, 'info');
                } else {
                    combinedXML = boundaryXML;
                    logProgressForPatch(patchId, 'No notes found, using boundary-only layer', 'info');
                }

                if (combinedXML.length > 50000) {
                    logProgressForPatch(patchId, 'Combined XML too large, falling back to boundary only', 'warning');
                    combinedXML = boundaryXML;
                }

                const encodedData = encodeURIComponent(combinedXML);
                const loadUrl = `${CONFIG.JOSM_BASE_URL}/load_data?` +
                    `new_layer=true&` +
                    `layer_name=${encodeURIComponent(`Patch ${patchId} - Boundary & Notes (DO NOT UPLOAD)`)}&` +
                    `upload_policy=never&` +
                    `layer_locked=true&` +
                    `data=${encodedData}`;
                
                const response = await fetch(loadUrl, {
                    method: 'GET',
                    signal: AbortSignal.timeout(CONFIG.JOSM_TIMEOUT)
                });
                
                if (!response.ok) {
                    throw new Error(`JOSM import failed (HTTP ${response.status})`);
                }
                
                const notesText = notes.length > 0 ? ` (${notes.length} notes + boundary)` : ' (boundary only)';
                logProgressForPatch(patchId, `‚úì Combined layer loaded${notesText} - LOCKED`, 'success');
                return true;

            } catch (err) {
                logProgressForPatch(patchId, `‚ö†Ô∏è Combined layer failed: ${err.message}`, 'warning');
                return false;
            }
        }
        
        // Zoom JOSM to specific bounding box
        async function zoomJOSMToBbox(bbox, patchId) {
            logProgressForPatch(patchId, 'Setting zoom to patch boundary...', 'info');
            
            try {
                const zoomUrl = `${CONFIG.JOSM_BASE_URL}/zoom?` +
                    `left=${bbox.min_lon}&` +
                    `bottom=${bbox.min_lat}&` +
                    `right=${bbox.max_lon}&` +
                    `top=${bbox.max_lat}`;
                
                const response = await fetch(zoomUrl, {
                    method: 'GET',
                    signal: AbortSignal.timeout(CONFIG.JOSM_TIMEOUT)
                });
                
                if (!response.ok) {
                    throw new Error(`JOSM zoom failed (HTTP ${response.status})`);
                }
                
                logProgressForPatch(patchId, '‚úì Zoomed to patch boundary', 'success');
                return true;
                
            } catch (error) {
                logProgressForPatch(patchId, `‚ö†Ô∏è Zoom failed: ${error.message}`, 'warning');
                return false;
            }
        }

        // Main patch loading function
        async function loadPatchInJOSM(patchId, buttonElement) {
            const mapperId = document.getElementById(`mapperId-${patchId}`).value.trim();
            if (!mapperId) {
                toast.show('Please enter your OpenStreetMap username before loading the patch.', 'warning');
                document.getElementById(`mapperId-${patchId}`).focus();
                return;
            }
            
            const originalText = buttonElement.innerHTML;
            buttonElement.innerHTML = '‚è≥ <span>Loading...</span>';
            buttonElement.disabled = true;
            
            try {
                logProgressForPatch(patchId, `Starting 2-layer patch load for ${mapperId}`, 'info');
                
                const patchData = await getPatchDetails(patchId);
                if (!patchData.bbox) throw new Error('Could not determine patch coordinates');
                
                logProgressForPatch(patchId, `Patch coordinates: ${Object.values(patchData.bbox).map(v => v.toFixed(6)).join(', ')}`, 'info');
                
                const josmStatus = await testJOSM();
                if (!josmStatus.connected) throw new Error(`JOSM not connected: ${josmStatus.error}`);
                
                logProgressForPatch(patchId, 'JOSM connection verified ‚úì', 'success');
                
                // Step 1: Load boundary+notes layer first
                buttonElement.innerHTML = 'üîó <span>Creating Merged Layer...</span>';
                
                const bboxString = `${patchData.bbox.min_lon},${patchData.bbox.min_lat},${patchData.bbox.max_lon},${patchData.bbox.max_lat}`;
                const notesApiUrl = `https://api.openstreetmap.org/api/0.6/notes.json?bbox=${bboxString}&limit=10000&closed=7`;

                logProgressForPatch(patchId, 'Fetching OSM notes...', 'info');

                let notesFeatures = [];
                try {
                    const notesResponse = await fetch(notesApiUrl, {
                        method: 'GET',
                        signal: AbortSignal.timeout(30000)
                    });
                    
                    if (notesResponse.ok) {
                        const notesData = await notesResponse.json();
                        notesFeatures = notesData.features;
                        logProgressForPatch(patchId, `Retrieved ${notesFeatures.length} notes`, 'info');
                    }
                } catch (notesError) {
                    logProgressForPatch(patchId, `Notes fetch failed: ${notesError.message}`, 'warning');
                }

                const mergedLoaded = await loadMergedBoundaryAndNotesInJOSM(patchData.bbox, notesFeatures, patchId);

                // Step 2: Load power infrastructure last (becomes active layer)
                buttonElement.innerHTML = 'üîå <span>Loading Power Data...</span>';
                const powerDataLoaded = await loadOverpassDataInJOSM(patchData.bbox, patchId);

                // Step 3: Zoom to boundary
                buttonElement.innerHTML = 'üîç <span>Setting Zoom...</span>';
                const zoomSet = await zoomJOSMToBbox(patchData.bbox, patchId);

                // Summary
                const results = [];
                if (mergedLoaded) results.push(`boundary+notes (${notesFeatures.length} notes)`);
                if (powerDataLoaded) results.push('power infrastructure (ACTIVE)');
                
                if (powerDataLoaded && mergedLoaded) {
                    const zoomText = zoomSet ? ' with proper zoom' : '';
                    logProgressForPatch(patchId, `üéâ Complete! Load successful${zoomText}`, 'success');
                    toast.show(`Patch ${patchId} loaded: ${results.join(' + ')}`, 'success');
                } else {
                    logProgressForPatch(patchId, `‚ö†Ô∏è Partial load: ${results.join(' + ')}`, 'warning');
                    toast.show(`Patch ${patchId} partially loaded`, 'warning');
                }
                
            } catch (error) {
                logProgressForPatch(patchId, `‚ùå Error: ${error.message}`, 'error');
                toast.show(`Failed to load patch: ${error.message}`, 'error');
            } finally {
                buttonElement.innerHTML = originalText;
                buttonElement.disabled = false;
            }
        }

        // Mark patch complete
        async function markPatchComplete(patchId) {
            const mapperId = document.getElementById(`mapperId-${patchId}`).value.trim();
            if (!mapperId) {
                toast.show('Please enter your OpenStreetMap username before marking complete.', 'warning');
                document.getElementById(`mapperId-${patchId}`).focus();
                return;
            }
            
            const mapperEmail = document.getElementById(`mapperEmail-${patchId}`).value.trim();
            const mappingNotes = document.getElementById(`mappingNotes-${patchId}`).value.trim();
            
            if (!confirm(`Mark Patch ${patchId} as complete?\n\nMapper: ${mapperId}\nThis action cannot be undone.`)) {
                return;
            }
            
            try {
                logProgressForPatch(patchId, 'Checking completion status...', 'info');
                
                const existing = await supabaseQuery(`/patch_assignments?select=status,mapper_id,completed_at&patch_id=eq.${patchId}&status=eq.completed&limit=1`);
                
                if (existing.length > 0) {
                    const existingAssignment = existing[0];
                    const completedDate = new Date(existingAssignment.completed_at).toLocaleString();
                    toast.show(`Patch already completed by ${existingAssignment.mapper_id} on ${completedDate}`, 'warning');
                    return;
                }
                
                logProgressForPatch(patchId, 'Creating completion record...', 'info');
                
                const completionData = {
                    patch_id: patchId,
                    mapper_id: mapperId,
                    mapper_email: mapperEmail || null,
                    status: 'completed',
                    assigned_at: new Date().toISOString(),
                    completed_at: new Date().toISOString(),
                    completion_notes: mappingNotes || null,
                    app_version: CONFIG.APP_VERSION
                };
                
                await supabaseQuery('/patch_assignments', {
                    method: 'POST',
                    body: JSON.stringify(completionData)
                });
                
                logProgressForPatch(patchId, 'üéâ Marked as completed!', 'success');
                toast.show(`Patch ${patchId} completed by ${mapperId}!`, 'success');
                
                closePatchExpansion(patchId);
                setTimeout(() => loadPatches(), 1500);
                
            } catch (error) {
                console.error('Error marking patch complete:', error);
                logProgressForPatch(patchId, `‚ùå Completion failed: ${error.message}`, 'error');
                toast.show(`Failed to mark complete: ${error.message}`, 'error');
            }
        }

        // Open in Overpass Turbo
        async function openOverpassLink(patchId) {
            try {
                const patchData = await getPatchDetails(patchId);
                const bbox = patchData.bbox;
                
                const overpassQuery = createOverpassQuery(bbox);
                const turboQuery = `/* Power Infrastructure for Patch ${patchId} */\n${overpassQuery}`;
                
                const encodedQuery = encodeURIComponent(turboQuery);
                const overpassUrl = `https://overpass-turbo.eu/?Q=${encodedQuery}&R`;
                
                window.open(overpassUrl, '_blank');
                logProgressForPatch(patchId, 'Opened in Overpass Turbo', 'success');
                toast.show('Opened patch in Overpass Turbo', 'info');
                
            } catch (error) {
                logProgressForPatch(patchId, `Overpass error: ${error.message}`, 'error');
                toast.show(`Failed to open Overpass: ${error.message}`, 'error');
            }
        }

        // Test JOSM connection
        async function testJOSM() {
            try {
                const response = await fetch(`${CONFIG.JOSM_BASE_URL}/version`, { 
                    method: 'GET',
                    signal: AbortSignal.timeout(5000)
                });
                
                if (response.ok) {
                    const version = await response.json();
                    return { 
                        connected: true, 
                        version,
                        message: 'JOSM connection successful!'
                    };
                } else {
                    return { 
                        connected: false, 
                        error: `HTTP ${response.status}: ${response.statusText}`,
                        help: 'Check JOSM remote control settings'
                    };
                }
            } catch (error) {
                return {
                    connected: false,
                    error: error.name === 'AbortError' ? 'Connection timeout (5s)' : error.message,
                    help: 'Make sure JOSM is running with remote control enabled'
                };
            }
        }
        
        // Test functions
        async function testOverpass() {
            const testBbox = { min_lat: 48.0, min_lon: 67.0, max_lat: 48.01, max_lon: 67.01 };
            const testQuery = createOverpassQuery(testBbox);
            const startTime = Date.now();
            
            try {
                showProgressIndicator('Testing Overpass API...');
                
                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: new URLSearchParams({ data: testQuery }),
                    signal: AbortSignal.timeout(30000)
                });
                
                const responseTime = Date.now() - startTime;
                
                if (response.ok) {
                    const osmData = await response.text();
                    const nodes = (osmData.match(/<node/g) || []).length;
                    const ways = (osmData.match(/<way/g) || []).length;
                    const relations = (osmData.match(/<relation/g) || []).length;
                    
                    const message = `‚úÖ Overpass API Test Successful\n\n‚è±Ô∏è Response time: ${responseTime}ms\nüìä Found: ${nodes} nodes, ${ways} ways, ${relations} relations\nüì¶ Data size: ${(osmData.length / 1024).toFixed(1)} KB\n\nThe API is responding normally.`;
                    alert(message);
                    toast.show('Overpass API test successful', 'success');
                } else {
                    const errorText = await response.text();
                    alert(`‚ùå Overpass API Error: ${response.status}\n${errorText.substring(0, 200)}`);
                    toast.show('Overpass API test failed', 'error');
                }
                
            } catch (error) {
                alert(`‚ùå Overpass Test Failed: ${error.message}`);
                toast.show(`Overpass test failed: ${error.message}`, 'error');
            } finally {
                hideProgressIndicator();
            }
        }

        window.testJOSMButton = async function() {
            showProgressIndicator('Testing JOSM connection...');
            
            try {
                const result = await testJOSM();
                
                if (result.connected) {
                    const message = `‚úÖ JOSM Connection Successful!\n\nüîß JOSM Version: ${result.version.application || 'Unknown'}\nüì° Remote Control: Active\nüåê Port 8111: Accessible\n\nReady for patch loading!`;
                    alert(message);
                    toast.show('JOSM connection verified', 'success');
                } else {
                    const message = `‚ùå JOSM Connection Failed\n\nError: ${result.error}\n\nTroubleshooting:\n1. Ensure JOSM is running\n2. Enable remote control: Edit ‚Üí Preferences ‚Üí Remote Control\n3. Check "Enable remote control"\n4. Restart JOSM after enabling\n5. Verify no firewall blocking port 8111`;
                    alert(message);
                    toast.show('JOSM connection failed', 'error');
                }
            } finally {
                hideProgressIndicator();
            }
        };
        
        async function debugDatabase() {
            try {
                showProgressIndicator('Gathering debug information...');
                
                const allPatches = await supabaseQuery('/osmose_patches?select=country_code,country_name&limit=1000');
                const completedPatches = await supabaseQuery('/patch_assignments?select=patch_id,status&status=eq.completed');
                
                const countryCounts = {};
                allPatches.forEach(patch => {
                    const code = patch.country_code;
                    countryCounts[code] = (countryCounts[code] || 0) + 1;
                });
                
                const topCountries = Object.entries(countryCounts)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 10);
                
                let message = 'üîç Database Debug Information\n\n';
                message += `üìä Statistics:\n`;
                message += `  Total patches: ${allPatches.length.toLocaleString()}\n`;
                message += `  Completed: ${completedPatches.length.toLocaleString()}\n`;
                message += `  Completion rate: ${((completedPatches.length / allPatches.length) * 100).toFixed(1)}%\n\n`;
                
                message += 'üåç Top Countries:\n';
                topCountries.forEach(([code, count]) => {
                    message += `  ${code}: ${count.toLocaleString()} patches\n`;
                });
                
                message += `\nüîß Technical Info:\n`;
                message += `  Version: ${CONFIG.APP_VERSION} (2-Layer + Zoom Fix)\n`;
                message += `  Connection: ${AppState.connectionStatus}\n`;
                message += `  Theme: ${AppState.theme}\n`;
                
                alert(message);
                toast.show('Debug information collected', 'info');
                
            } catch (error) {
                alert(`‚ùå Debug failed: ${error.message}`);
                toast.show(`Debug failed: ${error.message}`, 'error');
            } finally {
                hideProgressIndicator();
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.isContentEditable) {
                return;
            }
            
            switch(event.key) {
                case 'Escape':
                    closeAllPatches();
                    break;
                case 'r':
                case 'R':
                    if (!AppState.isLoading) {
                        event.preventDefault();
                        loadPatches();
                    }
                    break;
                case 't':
                case 'T':
                    event.preventDefault();
                    testJOSMButton();
                    break;
                case '?':
                    event.preventDefault();
                    toggleKeyboardHelp();
                    break;
                case 'd':
                case 'D':
                    if (event.ctrlKey || event.metaKey) {
                        event.preventDefault();
                        themeManager.toggle();
                    }
                    break;
            }
        });

        function toggleKeyboardHelp() {
            const help = document.getElementById('keyboardHelp');
            help.style.display = help.style.display === 'block' ? 'none' : 'block';
        }

        // Initialize application
        window.addEventListener('load', async () => {
            updateConnectionStatus(false, 'Connecting...');
            
            document.getElementById('themeToggle').addEventListener('click', () => {
                themeManager.toggle();
            });
            
            let connected = false;
            for (let attempt = 1; attempt <= 3 && !connected; attempt++) {
                connected = await testConnection();
                if (!connected && attempt < 3) {
                    logProgress(`Connection attempt ${attempt} failed, retrying...`, 'warning');
                    await new Promise(resolve => setTimeout(resolve, 2000 * attempt));
                }
            }
            
            if (connected) {
                loadPatches();
                toast.show('Game of Grids loaded successfully!', 'success');
            } else {
                document.getElementById('patches').innerHTML = 
                    `<div class="error-state">
                        <div class="error-icon">‚ùå</div>
                        <h3>Database connection failed</h3>
                        <p>Unable to connect after multiple attempts.</p>
                        <button onclick="window.location.reload()" class="button refresh-button">üîÑ Reload Page</button>
                    </div>`;
                toast.show('Failed to connect to database', 'error');
            }
        });
        
        // Auto-refresh patches periodically
        setInterval(() => {
            if (Date.now() - AppState.lastRefresh > CONFIG.REFRESH_INTERVAL && 
                !AppState.isLoading && 
                AppState.connectionStatus === 'online') {
                loadPatches();
            }
        }, 60000);
        
        // Online/offline handling
        window.addEventListener('online', async () => {
            toast.show('Connection restored', 'success');
            await testConnection();
            if (AppState.connectionStatus === 'online') loadPatches();
        });

        window.addEventListener('offline', () => {
            updateConnectionStatus(false, 'No Internet');
            toast.show('Connection lost', 'warning');
        });
    </script>
</body>
</html>