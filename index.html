<!DOCTYPE html>
<html lang="en">
<head>
    <title>Game of Grids - Power Infrastructure Mapping</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Collaborative power infrastructure mapping using OpenStreetMap and JOSM">
    <meta name="theme-color" content="#036d7a">
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>⚡</text></svg>">
</head>
<body>
    <!-- Toast notification system -->
    <div id="toastContainer" class="toast-container"></div>
    
    <!-- Loading overlay -->
    <div id="loadingOverlay" class="loading-overlay">
        <div class="loading-spinner">⚡</div>
        <div class="loading-text">Loading patches...</div>
    </div>
    
    <!-- Theme toggle -->
    <button id="themeToggle" class="theme-toggle" title="Toggle dark mode" aria-label="Toggle dark mode">
        <span class="theme-icon">🌙</span>
    </button>
    
    <div class="connection-status" id="connectionStatus" role="status" aria-live="polite">
        🌐 Connecting...
    </div>
    
    <div class="container">
        <header class="header">
            <h1>⚡ Game of Grids</h1>
            <p>Collaborative Power Infrastructure Mapping with OpenStreetMap</p>
        </header>
        
        <!-- Enhanced prerequisite section -->
        <section class="warning" role="region" aria-labelledby="prerequisites-heading">
            <h2 id="prerequisites-heading">🔧 Prerequisites</h2>
            <div class="feature-grid">
                <div class="feature-item">
                    <span class="feature-icon">✅</span>
                    <div>
                        <strong>JOSM Editor</strong>
                        <p>Running with remote control enabled</p>
                    </div>
                </div>
                <div class="feature-item">
                    <span class="feature-icon">🌐</span>
                    <div>
                        <strong>Internet Connection</strong>
                        <p>Stable connection required</p>
                    </div>
                </div>
                <div class="feature-item">
                    <span class="feature-icon">🔍</span>
                    <div>
                        <strong>Remote Control</strong>
                        <p>Edit → Preferences → Remote Control</p>
                    </div>
                </div>
                <div class="feature-item">
                    <span class="feature-icon">📡</span>
                    <div>
                        <strong>Port 8111</strong>
                        <p>Default JOSM listening port</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Enhanced workflow section -->
        <section class="info" role="region" aria-labelledby="workflow-heading">
            <h2 id="workflow-heading">🚨 Mapping Workflow</h2>
            <div class="workflow-steps">
                <div class="workflow-step">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <h3>🎯 Load Patch</h3>
                        <p>Click Load to zoom JOSM to patch area with boundaries</p>
                    </div>
                </div>
                <div class="workflow-step">
                    <div class="step-number">2</div>
                    <div class="step-content">
                        <h3>📥 Download Data</h3>
                        <p>Use JOSM download dialog or Overpass Turbo for power data</p>
                    </div>
                </div>
                <div class="workflow-step">
                    <div class="step-number">3</div>
                    <div class="step-content">
                        <h3>🗺️ Map Features</h3>
                        <p>Add all power infrastructure in the designated area</p>
                    </div>
                </div>
                <div class="workflow-step">
                    <div class="step-number">4</div>
                    <div class="step-content">
                        <h3>✅ Mark Complete</h3>
                        <p>Submit your completion with notes and username</p>
                    </div>
                </div>
            </div>
        </section>
        
        <!-- Enhanced mapping targets -->
        <section class="info" role="region" aria-labelledby="targets-heading">
            <h2 id="targets-heading">🎯 Power Infrastructure to Map</h2>
            <div class="feature-grid">
                <div class="feature-item">
                    <span class="feature-icon">⚡</span>
                    <div>
                        <strong>Power Lines</strong>
                        <p>All power lines & cables</p>
                    </div>
                </div>
                <div class="feature-item">
                    <span class="feature-icon">🗼</span>
                    <div>
                        <strong>Support Structures</strong>
                        <p>Towers, poles, portals & terminals</p>
                    </div>
                </div>
                <div class="feature-item">
                    <span class="feature-icon">🏭</span>
                    <div>
                        <strong>Facilities</strong>
                        <p>Substations, transformers, plants & generators</p>
                    </div>
                </div>
                <div class="feature-item">
                    <span class="feature-icon">☀️</span>
                    <div>
                        <strong>Renewables</strong>
                        <p>Solar panels & wind turbines</p>
                    </div>
                </div>
            </div>
        </section>
        
        <!-- Enhanced controls with better accessibility -->
        <section class="controls" role="region" aria-labelledby="controls-heading">
            <h2 id="controls-heading" class="sr-only">Application Controls</h2>
            <div class="controls-grid">
                <div class="control-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="showCompleted" onchange="loadPatches()" aria-describedby="completed-help">
                        <span class="checkmark"></span>
                        <span>Show completed patches</span>
                    </label>
                    <small id="completed-help" class="help-text">Include patches that have been marked as complete</small>
                </div>
                
                <div class="control-group">
                    <label for="countryCode" class="control-label">Country Code:</label>
                    <div class="input-with-validation">
                        <input 
                            type="text" 
                            id="countryCode" 
                            value="KZ" 
                            maxlength="2" 
                            pattern="[A-Z]{2}" 
                            onchange="validateAndLoadPatches()" 
                            oninput="this.value = this.value.toUpperCase()"
                            placeholder="e.g. KZ" 
                            aria-describedby="country-help"
                            autocomplete="country"
                        >
                        <div class="validation-message" id="countryValidation"></div>
                    </div>
                    <small id="country-help" class="help-text">Enter 2-letter ISO country code</small>
                </div>
                
                <div class="action-buttons">
                    <button onclick="loadPatches()" class="button refresh-button" aria-describedby="refresh-help">
                        🔄 <span>Refresh Patches</span>
                    </button>
                    <button onclick="testJOSMButton()" class="button test-button" aria-describedby="josm-help">
                        🧪 <span>Test JOSM</span>
                    </button>
                    <button onclick="testOverpass()" class="button overpass-button" aria-describedby="overpass-help">
                        🌐 <span>Test Overpass</span>
                    </button>
                    <button onclick="debugDatabase()" class="button debug-button" aria-describedby="debug-help">
                        🔍 <span>Debug Info</span>
                    </button>
                </div>
            </div>
            
            <!-- Help tooltips -->
            <div class="help-tooltips">
                <small id="refresh-help" class="help-text">Reload patches from database</small>
                <small id="josm-help" class="help-text">Check JOSM connection and remote control</small>
                <small id="overpass-help" class="help-text">Test Overpass API availability</small>
                <small id="debug-help" class="help-text">Show database statistics and connection info</small>
            </div>
        </section>
        
        <!-- Enhanced stats display -->
        <div id="stats" class="stats" role="status" aria-live="polite"></div>
        
        <!-- Progress indicators -->
        <div id="progressIndicator" class="progress-indicator">
            <div class="progress-bar">
                <div class="progress-fill"></div>
            </div>
            <div class="progress-text">Loading...</div>
        </div>
        
        <div id="progressLog" class="progress-log" role="log" aria-live="polite"></div>
        
        <!-- Main content area -->
        <main class="grid" role="main">
            <div class="cards-container" id="patches" aria-live="polite" aria-label="Available mapping patches">
                <!-- Patches will be rendered here -->
            </div>
        </main>
        
        <!-- Keyboard shortcuts help -->
        <div id="keyboardHelp" class="keyboard-help">
            <h3>⌨️ Keyboard Shortcuts</h3>
            <div class="shortcut-list">
                <div class="shortcut-item"><kbd>Esc</kbd> Close expanded patch</div>
                <div class="shortcut-item"><kbd>R</kbd> Refresh patches</div>
                <div class="shortcut-item"><kbd>T</kbd> Test JOSM</div>
                <div class="shortcut-item"><kbd>?</kbd> Toggle this help</div>
            </div>
        </div>
    </div>
    
    <div class="patch-overlay" id="patchOverlay" onclick="closeAllPatches()" role="button" tabindex="0" aria-label="Close expanded patch"></div>
    
    <script>
        'use strict';
        
        // Enhanced configuration with validation
        const CONFIG = {
            SUPABASE_URL: 'https://teumppdbhbrozswbpond.supabase.co/rest/v1',
            SUPABASE_KEY: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRldW1wcGRiaGJyb3pzd2Jwb25kIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTAyMjY2MDYsImV4cCI6MjA2NTgwMjYwNn0.8j2yv4SuZJXnHV_spPIQQGsPBrvZrmYld6IlT7Omu7E',
            JOSM_BASE_URL: 'http://localhost:8111',
            JOSM_TIMEOUT: 30000,
            REFRESH_INTERVAL: 300000, // 5 minutes
            MAX_RETRIES: 3,
            PAGINATION_SIZE: 50
        };
        
        // Application state management
        const AppState = {
            currentPatches: [],
            isLoading: false,
            connectionStatus: 'connecting',
            retryCount: 0,
            theme: localStorage.getItem('theme') || 'light',
            lastRefresh: Date.now()
        };

        // Enhanced toast notification system
        class ToastManager {
            constructor() {
                this.container = document.getElementById('toastContainer');
            }
            
            show(message, type = 'info', duration = 5000) {
                const toast = document.createElement('div');
                toast.className = `toast toast-${type}`;
                toast.setAttribute('role', 'alert');
                toast.setAttribute('aria-live', 'assertive');
                
                const icon = this.getIcon(type);
                toast.innerHTML = `
                    <div class="toast-content">
                        <span class="toast-icon">${icon}</span>
                        <span class="toast-message">${message}</span>
                        <button class="toast-close" onclick="this.parentElement.parentElement.remove()" aria-label="Close notification">×</button>
                    </div>
                `;
                
                this.container.appendChild(toast);
                
                // Auto-remove after duration
                if (duration > 0) {
                    setTimeout(() => {
                        if (toast.parentElement) {
                            toast.remove();
                        }
                    }, duration);
                }
                
                return toast;
            }
            
            getIcon(type) {
                const icons = {
                    success: '✅',
                    error: '❌', 
                    warning: '⚠️',
                    info: 'ℹ️'
                };
                return icons[type] || 'ℹ️';
            }
            
            clear() {
                this.container.innerHTML = '';
            }
        }
        
        const toast = new ToastManager();

        // Enhanced theme management
        class ThemeManager {
            constructor() {
                this.applyTheme(AppState.theme);
                this.updateToggleButton();
            }
            
            toggle() {
                AppState.theme = AppState.theme === 'light' ? 'dark' : 'light';
                this.applyTheme(AppState.theme);
                localStorage.setItem('theme', AppState.theme);
                this.updateToggleButton();
            }
            
            applyTheme(theme) {
                document.documentElement.setAttribute('data-theme', theme);
            }
            
            updateToggleButton() {
                const button = document.getElementById('themeToggle');
                const icon = button.querySelector('.theme-icon');
                icon.textContent = AppState.theme === 'light' ? '🌙' : '☀️';
                button.setAttribute('aria-label', `Switch to ${AppState.theme === 'light' ? 'dark' : 'light'} mode`);
            }
        }
        
        const themeManager = new ThemeManager();

        // Enhanced progress logging with better UX
        function logProgress(message, type = 'info') {
            const log = document.getElementById('progressLog');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.setAttribute('role', 'status');
            
            const timestamp = new Date().toLocaleTimeString();
            entry.innerHTML = `
                <span class="log-timestamp">[${timestamp}]</span>
                <span class="log-message">${message}</span>
            `;
            
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
            
            // Limit log entries to prevent memory issues
            const entries = log.querySelectorAll('.log-entry');
            if (entries.length > 100) {
                entries[0].remove();
            }
            
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function showProgressIndicator(text = 'Loading...') {
            const indicator = document.getElementById('progressIndicator');
            const overlay = document.getElementById('loadingOverlay');
            const textElement = overlay.querySelector('.loading-text');
            
            textElement.textContent = text;
            indicator.classList.add('active');
            overlay.classList.add('active');
        }

        function hideProgressIndicator() {
            const indicator = document.getElementById('progressIndicator');
            const overlay = document.getElementById('loadingOverlay');
            
            indicator.classList.remove('active');
            overlay.classList.remove('active');
        }

        // Enhanced Supabase integration with better error handling
        function getSupabaseHeaders() {
            return {
                'apikey': CONFIG.SUPABASE_KEY,
                'Authorization': `Bearer ${CONFIG.SUPABASE_KEY}`,
                'Content-Type': 'application/json',
                'Prefer': 'return=representation'
            };
        }

        async function supabaseQuery(endpoint, options = {}) {
            const url = `${CONFIG.SUPABASE_URL}${endpoint}`;
            
            for (let attempt = 1; attempt <= CONFIG.MAX_RETRIES; attempt++) {
                try {
                    const response = await fetch(url, {
                        ...options,
                        headers: {
                            ...getSupabaseHeaders(),
                            ...options.headers
                        }
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Supabase error: ${response.status} ${response.statusText}`);
                    }
                    
                    return await response.json();
                    
                } catch (error) {
                    if (attempt === CONFIG.MAX_RETRIES) {
                        throw error;
                    }
                    
                    logProgress(`Attempt ${attempt} failed, retrying... (${error.message})`, 'warning');
                    await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                }
            }
        }

        // Enhanced connection status management
        function updateConnectionStatus(online, message = '') {
            const status = document.getElementById('connectionStatus');
            AppState.connectionStatus = online ? 'online' : 'offline';
            
            if (online) {
                status.className = 'connection-status connection-online';
                status.textContent = '🌐 Online';
                status.setAttribute('aria-label', 'Database connection is online');
            } else {
                status.className = 'connection-status connection-offline';
                status.textContent = `❌ ${message || 'Offline'}`;
                status.setAttribute('aria-label', `Database connection is offline: ${message || 'Unknown error'}`);
            }
        }

        // Enhanced validation
        function validateCountryCode(code) {
            const trimmed = code.trim().toUpperCase();
            const isValid = /^[A-Z]{2}$/.test(trimmed);
            
            const validation = document.getElementById('countryValidation');
            if (!isValid && trimmed.length > 0) {
                validation.textContent = 'Please enter a valid 2-letter country code';
                validation.className = 'validation-message error';
                return false;
            } else {
                validation.textContent = '';
                validation.className = 'validation-message';
                return true;
            }
        }

        function validateAndLoadPatches() {
            const countryCode = document.getElementById('countryCode').value;
            if (validateCountryCode(countryCode)) {
                loadPatches();
            }
        }

        // Enhanced connection testing
        async function testConnection() {
            try {
                await supabaseQuery('/osmose_patches?select=count&limit=1');
                updateConnectionStatus(true);
                AppState.retryCount = 0;
                return true;
            } catch (error) {
                updateConnectionStatus(false, 'DB Error');
                console.error('Database connection failed:', error);
                AppState.retryCount++;
                return false;
            }
        }
        
        function setLoading(loading) {
            AppState.isLoading = loading;
            const patches = document.getElementById('patches');
            
            if (loading) {
                patches.classList.add('loading');
                showProgressIndicator('Loading patches...');
            } else {
                patches.classList.remove('loading');
                hideProgressIndicator();
            }
        }
        
        // Enhanced patch loading with better error handling and UX
        async function loadPatches() {
            if (AppState.isLoading) return;
            
            setLoading(true);
            const showCompleted = document.getElementById('showCompleted').checked;
            const countryCode = document.getElementById('countryCode').value.toUpperCase() || 'KZ';
            
            if (!validateCountryCode(countryCode)) {
                setLoading(false);
                return;
            }
            
            try {
                logProgress(`Loading patches for ${countryCode}...`, 'info');
                
                // Test connection first
                const connected = await testConnection();
                if (!connected) {
                    throw new Error('Database connection failed');
                }

                // Build optimized query
                let query = `/osmose_patches?select=patch_id,country_code,country_name,error_count,area_km2,perimeter_km,priority,difficulty,created_at&country_code=eq.${countryCode}&order=priority.desc,created_at.asc&limit=${CONFIG.PAGINATION_SIZE}`;
                
                const patches = await supabaseQuery(query);
                logProgress(`Found ${patches.length} patches in database`, 'success');
                
                // Enhanced filtering for completed patches
                let filteredPatches = patches;
                if (!showCompleted) {
                    const completedQuery = `/patch_assignments?select=patch_id&status=eq.completed`;
                    const completedPatches = await supabaseQuery(completedQuery);
                    const completedIds = new Set(completedPatches.map(p => p.patch_id));
                    
                    filteredPatches = patches.filter(p => !completedIds.has(p.patch_id));
                    logProgress(`Filtered to ${filteredPatches.length} incomplete patches`, 'info');
                }
                
                AppState.currentPatches = filteredPatches;
                
                // Add status information with better performance
                const patchIds = AppState.currentPatches.map(p => p.patch_id);
                const statusQuery = `/patch_assignments?select=patch_id,status&patch_id=in.(${patchIds.join(',')})&status=eq.completed`;
                const completedStatuses = await supabaseQuery(statusQuery);
                const completedMap = new Map(completedStatuses.map(s => [s.patch_id, s.status]));
                
                AppState.currentPatches.forEach(patch => {
                    patch.status = completedMap.get(patch.patch_id) || 'available';
                });
                
                renderPatches(AppState.currentPatches);
                AppState.lastRefresh = Date.now();
                
                toast.show(`Loaded ${AppState.currentPatches.length} patches for ${countryCode}`, 'success');
                
            } catch (error) {
                console.error('Error loading patches:', error);
                logProgress(`Error: ${error.message}`, 'error');
                updateConnectionStatus(false, 'Load Error');
                
                document.getElementById('patches').innerHTML = 
                    `<div class="error-state">
                        <div class="error-icon">❌</div>
                        <h3>Error loading patches</h3>
                        <p>${error.message}</p>
                        <p>Please check your internet connection and database access.</p>
                        <button onclick="loadPatches()" class="button refresh-button">🔄 Try Again</button>
                    </div>`;
                
                toast.show(`Failed to load patches: ${error.message}`, 'error');
            } finally {
                setLoading(false);
            }
        }
        
        // Enhanced patch rendering with better accessibility
        function renderPatches(patches) {
            const container = document.getElementById('patches');
            
            if (patches.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">🔍</div>
                        <h3>No patches found</h3>
                        <p>Try a different country code or enable "Show completed patches"</p>
                        <button onclick="loadPatches()" class="button refresh-button">🔄 Refresh</button>
                    </div>`;
                return;
            }
            
            // Update stats with better formatting
            const countryCode = document.getElementById('countryCode').value.toUpperCase() || 'KZ';
            const completedCount = patches.filter(p => p.status === 'completed').length;
            const availableCount = patches.length - completedCount;
            
            document.getElementById('stats').innerHTML = 
                `📊 Showing <strong>${patches.length}</strong> patches for <strong>${countryCode}</strong> 
                 • <span class="stat-available">${availableCount} available</span> 
                 • <span class="stat-completed">${completedCount} completed</span>`;
            
            container.innerHTML = patches.map(patch => {
                const statusClass = patch.status === 'completed' ? 'completed' : '';
                const difficultyClass = patch.difficulty ? `difficulty-${patch.difficulty.toLowerCase()}` : 'difficulty-medium';
                
                return `
                    <article class="patch ${statusClass} ${difficultyClass}" id="patch-${patch.patch_id}" 
                             tabindex="0" role="button" 
                             onclick="togglePatchExpansion('${patch.patch_id}')"
                             onkeydown="handlePatchKeydown(event, '${patch.patch_id}')"
                             aria-expanded="false"
                             aria-describedby="patch-${patch.patch_id}-desc">
                        
                        <div class="status-badge ${patch.status === 'completed' ? 'completed-badge' : 'available'}"
                             aria-label="Patch status: ${patch.status}">
                            ${patch.status.toUpperCase()}
                        </div>
                        
                        <header class="patch-header">
                            <h3>🗺️ Patch ${patch.patch_id}</h3>
                            <div class="patch-meta">
                                <span class="patch-country">${patch.country_name || patch.country_code}</span>
                                <span class="patch-date">${new Date(patch.created_at).toLocaleDateString()}</span>
                            </div>
                        </header>
                        
                        <div class="patch-grid">
                            <div class="patch-stat">
                                <strong>Area</strong>
                                <span>${patch.area_km2 ? patch.area_km2.toFixed(2) + ' km²' : 'N/A'}</span>
                            </div>
                            <div class="patch-stat">
                                <strong>Priority</strong>
                                <span>${patch.priority || 'Medium'}</span>
                            </div>
                            <div class="patch-stat">
                                <strong>Errors</strong>
                                <span>${patch.error_count || 0}</span>
                            </div>
                            <div class="patch-stat">
                                <strong>Difficulty</strong>
                                <span class="difficulty-indicator">${patch.difficulty || 'Medium'}</span>
                            </div>
                        </div>
                        
                        <div id="patch-${patch.patch_id}-desc" class="patch-summary">
                            ${patch.status === 'completed' ? 
                                '<div class="completion-indicator">✅ Mapping completed</div>' :
                                '<div class="action-hint">📍 Click to start mapping</div>'
                            }
                        </div>
                        
                        <!-- Enhanced Expanded Content -->
                        <div class="patch-expanded-content" onclick="event.stopPropagation()">
                            <div class="expanded-inner">
                                <header class="expanded-header">
                                    <h4>🗺️ Patch ${patch.patch_id} Details</h4>
                                    <button class="close-button-header" onclick="closePatchExpansion('${patch.patch_id}'); event.stopPropagation();" aria-label="Close patch details">×</button>
                                </header>
                                
                                <div class="form-sections">
                                    <section class="form-section">
                                        <h5>👤 Mapper Information</h5>
                                        <div class="form-row">
                                            <div class="form-group">
                                                <label for="mapperId-${patch.patch_id}">
                                                    OpenStreetMap Username *
                                                    <span class="required-indicator" aria-label="Required field">*</span>
                                                </label>
                                                <input type="text" 
                                                       id="mapperId-${patch.patch_id}" 
                                                       required 
                                                       autocomplete="username"
                                                       placeholder="Your OSM username"
                                                       aria-describedby="mapperId-${patch.patch_id}-help">
                                                <small id="mapperId-${patch.patch_id}-help" class="help-text">
                                                    Your OpenStreetMap account username for attribution
                                                </small>
                                            </div>
                                            <div class="form-group">
                                                <label for="mapperEmail-${patch.patch_id}">Email (Optional)</label>
                                                <input type="email" 
                                                       id="mapperEmail-${patch.patch_id}" 
                                                       autocomplete="email"
                                                       placeholder="your@email.com"
                                                       aria-describedby="mapperEmail-${patch.patch_id}-help">
                                                <small id="mapperEmail-${patch.patch_id}-help" class="help-text">
                                                    For coordination and updates (optional)
                                                </small>
                                            </div>
                                        </div>
                                    </section>
                                    
                                    <section class="form-section">
                                        <h5>📋 Patch Information</h5>
                                        <div class="info-grid">
                                            <div class="info-item">
                                                <strong>Country:</strong> ${patch.country_name || patch.country_code}
                                            </div>
                                            <div class="info-item">
                                                <strong>Area:</strong> ${patch.area_km2 ? patch.area_km2.toFixed(2) + ' km²' : 'N/A'}
                                            </div>
                                            <div class="info-item">
                                                <strong>Perimeter:</strong> ${patch.perimeter_km ? patch.perimeter_km.toFixed(2) + ' km' : 'N/A'}
                                            </div>
                                            <div class="info-item">
                                                <strong>Reported Errors:</strong> ${patch.error_count || 0}
                                            </div>
                                            <div class="info-item">
                                                <strong>Priority:</strong> ${patch.priority || 'Medium'}
                                            </div>
                                            <div class="info-item">
                                                <strong>Difficulty:</strong> ${patch.difficulty || 'Medium'}
                                            </div>
                                        </div>
                                    </section>
                                    
                                    <section class="form-section">
                                        <h5>📝 Completion Notes</h5>
                                        <div class="form-group">
                                            <label for="mappingNotes-${patch.patch_id}">
                                                Notes about your mapping work (Optional)
                                            </label>
                                            <textarea id="mappingNotes-${patch.patch_id}" 
                                                      placeholder="Add notes about features found, issues encountered, or other relevant information..."
                                                      aria-describedby="mappingNotes-${patch.patch_id}-help"></textarea>
                                            <small id="mappingNotes-${patch.patch_id}-help" class="help-text">
                                                Help future mappers by describing what you found or any challenges
                                            </small>
                                        </div>
                                    </section>
                                </div>
                                
                                <div class="action-buttons">
                                    <button class="button load-button" 
                                            onclick="loadPatchInJOSM('${patch.patch_id}', this); event.stopPropagation();"
                                            aria-describedby="load-${patch.patch_id}-help">
                                        🚀 <span>Load in JOSM</span>
                                    </button>
                                    <button class="button complete-button" 
                                            onclick="markPatchComplete('${patch.patch_id}'); event.stopPropagation();"
                                            aria-describedby="complete-${patch.patch_id}-help">
                                        ✅ <span>Mark Complete</span>
                                    </button>
                                    <button class="button overpass-button" 
                                            onclick="openOverpassLink('${patch.patch_id}'); event.stopPropagation();"
                                            aria-describedby="overpass-${patch.patch_id}-help">
                                        🌐 <span>Open in Overpass</span>
                                    </button>
                                    <button class="close-button" 
                                            onclick="closePatchExpansion('${patch.patch_id}'); event.stopPropagation();"
                                            aria-label="Close patch details">
                                        ✕ <span>Close</span>
                                    </button>
                                </div>
                                
                                <div class="help-tooltips">
                                    <small id="load-${patch.patch_id}-help" class="help-text">Load patch boundaries in JOSM for mapping</small>
                                    <small id="complete-${patch.patch_id}-help" class="help-text">Mark this patch as completed with your username</small>
                                    <small id="overpass-${patch.patch_id}-help" class="help-text">Open Overpass Turbo with pre-filtered power infrastructure query</small>
                                </div>
                                
                                <div id="progressLog-${patch.patch_id}" class="progress-log" role="log" aria-live="polite"></div>
                            </div>
                        </div>
                    </article>
                `;
            }).join('');
        }

        // Enhanced keyboard navigation
        function handlePatchKeydown(event, patchId) {
            if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault();
                togglePatchExpansion(patchId);
            }
        }

        // Enhanced patch expansion with better accessibility
        function togglePatchExpansion(patchId) {
            const patchElement = document.getElementById(`patch-${patchId}`);
            const overlay = document.getElementById('patchOverlay');
            
            if (!patchElement) return;
            
            const isExpanded = patchElement.classList.contains('expanded');
            
            // Close all expanded patches first
            closeAllPatches();
            
            // Toggle current patch if it wasn't already expanded
            if (!isExpanded) {
                patchElement.classList.add('expanded');
                patchElement.setAttribute('aria-expanded', 'true');
                overlay.classList.add('active');
                document.body.style.overflow = 'hidden';
                
                // Focus the first input in the expanded patch
                setTimeout(() => {
                    const firstInput = patchElement.querySelector('input[type="text"]');
                    if (firstInput) firstInput.focus();
                }, 100);
                
                logProgress(`Opened patch ${patchId} for editing`, 'info');
            }
        }
        
        function closePatchExpansion(patchId) {
            const patchElement = document.getElementById(`patch-${patchId}`);
            const overlay = document.getElementById('patchOverlay');
            
            if (patchElement) {
                patchElement.classList.remove('expanded');
                patchElement.setAttribute('aria-expanded', 'false');
                patchElement.focus(); // Return focus to the patch card
            }
            overlay.classList.remove('active');
            document.body.style.overflow = '';
            
            logProgress(`Closed patch ${patchId}`, 'info');
        }
        
        function closeAllPatches() {
            const overlay = document.getElementById('patchOverlay');
            document.querySelectorAll('.patch.expanded').forEach(patch => {
                patch.classList.remove('expanded');
                patch.setAttribute('aria-expanded', 'false');
            });
            overlay.classList.remove('active');
            document.body.style.overflow = '';
        }

        // Enhanced progress logging for patches
        function logProgressForPatch(patchId, message, type = 'info') {
            const log = document.getElementById(`progressLog-${patchId}`);
            if (!log) return;
            
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.setAttribute('role', 'status');
            
            const timestamp = new Date().toLocaleTimeString();
            entry.innerHTML = `
                <span class="log-timestamp">[${timestamp}]</span>
                <span class="log-message">${message}</span>
            `;
            
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
            log.classList.add('active');
            
            // Limit entries per patch log
            const entries = log.querySelectorAll('.log-entry');
            if (entries.length > 20) {
                entries[0].remove();
            }
            
            console.log(`[${type.toUpperCase()}] Patch ${patchId}: ${message}`);
        }

        // Enhanced JOSM and patch loading
        async function getPatchDetails(patchId) {
            try {
                logProgressForPatch(patchId, 'Fetching patch geometry...', 'info');
                
                const patchQuery = `/osmose_patches?select=*&patch_id=eq.${patchId}&limit=1`;
                const patches = await supabaseQuery(patchQuery);
                
                if (patches.length === 0) {
                    throw new Error('Patch not found in database');
                }
                
                const patch = patches[0];
                let bbox;
                
                if (patch.geometry) {
                    try {
                        const geom = typeof patch.geometry === 'string' ? JSON.parse(patch.geometry) : patch.geometry;
                        
                        if (geom && geom.coordinates) {
                            let allCoords = [];
                            if (geom.type === 'Polygon') {
                                allCoords = geom.coordinates[0];
                            } else if (geom.type === 'MultiPolygon') {
                                allCoords = geom.coordinates.flat(2);
                            }
                            
                            if (allCoords.length > 0) {
                                const lons = allCoords.map(coord => coord[0]);
                                const lats = allCoords.map(coord => coord[1]);
                                
                                bbox = {
                                    min_lat: Math.min(...lats),
                                    min_lon: Math.min(...lons),
                                    max_lat: Math.max(...lats),
                                    max_lon: Math.max(...lons)
                                };
                                
                                logProgressForPatch(patchId, 'Geometry parsed successfully', 'success');
                            }
                        }
                    } catch (geomError) {
                        logProgressForPatch(patchId, `Geometry parsing warning: ${geomError.message}`, 'warning');
                    }
                }
                
                if (!bbox) {
                    logProgressForPatch(patchId, 'Using fallback coordinates', 'warning');
                    bbox = {
                        min_lat: 48.0,
                        min_lon: 67.0,
                        max_lat: 48.02,
                        max_lon: 67.02
                    };
                }
                
                // Add padding for better mapping context
                const padding = 0.002;
                bbox.min_lat -= padding;
                bbox.min_lon -= padding;
                bbox.max_lat += padding;
                bbox.max_lon += padding;
                
                return { ...patch, bbox };
                
            } catch (error) {
                logProgressForPatch(patchId, `Error getting patch details: ${error.message}`, 'error');
                throw error;
            }
        }
        
        async function loadJOSMDirect(bbox, patchId) {
            const params = new URLSearchParams({
                left: bbox.min_lon.toFixed(6),
                right: bbox.max_lon.toFixed(6),
                top: bbox.max_lat.toFixed(6),
                bottom: bbox.min_lat.toFixed(6),
                new_layer: 'true',
                layer_name: `Patch ${patchId} - Power Infrastructure Mapping`
            });
            
            logProgressForPatch(patchId, 'Sending load request to JOSM...', 'info');
            
            const response = await fetch(`${CONFIG.JOSM_BASE_URL}/load_and_zoom?${params}`, {
                method: 'GET',
                signal: AbortSignal.timeout(CONFIG.JOSM_TIMEOUT)
            });
            
            if (!response.ok) {
                throw new Error(`JOSM responded with HTTP ${response.status}: ${response.statusText}`);
            }
            
            logProgressForPatch(patchId, 'JOSM load request successful', 'success');
            return true;
        }
        
        async function loadPatchInJOSM(patchId, buttonElement) {
            const mapperId = document.getElementById(`mapperId-${patchId}`).value.trim();
            if (!mapperId) {
                toast.show('Please enter your OpenStreetMap username before loading the patch.', 'warning');
                document.getElementById(`mapperId-${patchId}`).focus();
                return;
            }
            
            const originalText = buttonElement.innerHTML;
            buttonElement.innerHTML = '⏳ <span>Loading...</span>';
            buttonElement.disabled = true;
            
            try {
                logProgressForPatch(patchId, `Starting load process for ${mapperId}`, 'info');
                
                const patchData = await getPatchDetails(patchId);
                
                if (!patchData.bbox) {
                    throw new Error('Could not determine patch coordinates');
                }
                
                logProgressForPatch(patchId, `Patch area: ${Object.values(patchData.bbox).map(v => v.toFixed(6)).join(', ')}`, 'info');
                
                const josmStatus = await testJOSM();
                if (!josmStatus.connected) {
                    throw new Error(`JOSM not connected: ${josmStatus.error}`);
                }
                
                logProgressForPatch(patchId, 'JOSM connection verified ✓', 'success');
                
                await loadJOSMDirect(patchData.bbox, patchId);
                
                logProgressForPatch(patchId, '🎉 Patch loaded successfully!', 'success');
                toast.show(`Patch ${patchId} loaded in JOSM for ${mapperId}`, 'success');
                
            } catch (error) {
                logProgressForPatch(patchId, `❌ Error: ${error.message}`, 'error');
                toast.show(`Failed to load patch: ${error.message}`, 'error');
            } finally {
                buttonElement.innerHTML = originalText;
                buttonElement.disabled = false;
            }
        }

        // Enhanced completion workflow
        async function markPatchComplete(patchId) {
            const mapperId = document.getElementById(`mapperId-${patchId}`).value.trim();
            if (!mapperId) {
                toast.show('Please enter your OpenStreetMap username before marking complete.', 'warning');
                document.getElementById(`mapperId-${patchId}`).focus();
                return;
            }
            
            const mapperEmail = document.getElementById(`mapperEmail-${patchId}`).value.trim();
            const mappingNotes = document.getElementById(`mappingNotes-${patchId}`).value.trim();
            
            if (!confirm(`Mark Patch ${patchId} as complete?\n\nMapper: ${mapperId}\nThis action cannot be undone.`)) {
                return;
            }
            
            try {
                logProgressForPatch(patchId, 'Checking completion status...', 'info');
                
                // Check if already completed
                const existingQuery = `/patch_assignments?select=status,mapper_id,completed_at&patch_id=eq.${patchId}&status=eq.completed&limit=1`;
                const existing = await supabaseQuery(existingQuery);
                
                if (existing.length > 0) {
                    const existingAssignment = existing[0];
                    const completedDate = new Date(existingAssignment.completed_at).toLocaleString();
                    toast.show(`Patch already completed by ${existingAssignment.mapper_id} on ${completedDate}`, 'warning');
                    return;
                }
                
                logProgressForPatch(patchId, 'Creating completion record...', 'info');
                
                // Create completion record with enhanced data
                const completionData = {
                    patch_id: patchId,
                    mapper_id: mapperId,
                    mapper_email: mapperEmail || null,
                    status: 'completed',
                    assigned_at: new Date().toISOString(),
                    completed_at: new Date().toISOString(),
                    completion_notes: mappingNotes || null,
                    app_version: '2.0.0' // Track which version was used
                };
                
                await supabaseQuery('/patch_assignments', {
                    method: 'POST',
                    body: JSON.stringify(completionData)
                });
                
                logProgressForPatch(patchId, '🎉 Marked as completed!', 'success');
                toast.show(`Patch ${patchId} completed by ${mapperId}!`, 'success');
                
                // Close expansion and refresh
                closePatchExpansion(patchId);
                setTimeout(() => {
                    loadPatches();
                }, 1500);
                
            } catch (error) {
                console.error('Error marking patch complete:', error);
                logProgressForPatch(patchId, `❌ Completion failed: ${error.message}`, 'error');
                toast.show(`Failed to mark complete: ${error.message}`, 'error');
            }
        }

        // Enhanced Overpass integration
        async function openOverpassLink(patchId) {
            try {
                const patchData = await getPatchDetails(patchId);
                const bbox = patchData.bbox;
                
                const overpassQuery = `[out:xml][timeout:60];
(
  node["power"](${bbox.min_lat},${bbox.min_lon},${bbox.max_lat},${bbox.max_lon});
  way["power"](${bbox.min_lat},${bbox.min_lon},${bbox.max_lat},${bbox.max_lon});
  relation["power"](${bbox.min_lat},${bbox.min_lon},${bbox.max_lat},${bbox.max_lon});
);
(._;>;);
out meta;`;

                const encodedQuery = encodeURIComponent(overpassQuery);
                const overpassUrl = `https://overpass-turbo.eu/?Q=${encodedQuery}&C=${((bbox.min_lat + bbox.max_lat) / 2).toFixed(6)};${((bbox.min_lon + bbox.max_lon) / 2).toFixed(6)};15`;
                
                window.open(overpassUrl, '_blank');
                logProgressForPatch(patchId, 'Opened in Overpass Turbo', 'success');
                toast.show('Opened patch in Overpass Turbo', 'info');
                
            } catch (error) {
                logProgressForPatch(patchId, `Overpass error: ${error.message}`, 'error');
                toast.show(`Failed to open Overpass: ${error.message}`, 'error');
            }
        }

        // Enhanced test functions
        async function testJOSM() {
            try {
                const response = await fetch(`${CONFIG.JOSM_BASE_URL}/version`, { 
                    method: 'GET',
                    signal: AbortSignal.timeout(5000)
                });
                
                if (response.ok) {
                    const version = await response.json();
                    return { 
                        connected: true, 
                        version,
                        message: 'JOSM connection successful!'
                    };
                } else {
                    return { 
                        connected: false, 
                        error: `HTTP ${response.status}: ${response.statusText}`,
                        help: 'Check JOSM remote control settings'
                    };
                }
            } catch (error) {
                return {
                    connected: false,
                    error: error.name === 'AbortError' ? 'Connection timeout (5s)' : error.message,
                    help: 'Make sure JOSM is running with remote control enabled'
                };
            }
        }
        
        async function testOverpass() {
            const testBbox = { min_lat: 48.0, min_lon: 67.0, max_lat: 48.01, max_lon: 67.01 };
            
            const testQuery = `[out:xml][timeout:30];
(
  node["power"](${testBbox.min_lat},${testBbox.min_lon},${testBbox.max_lat},${testBbox.max_lon});
  way["power"](${testBbox.min_lat},${testBbox.min_lon},${testBbox.max_lat},${testBbox.max_lon});
);
(._;>;);
out meta;`;

            console.log('🧪 Testing Overpass API...');
            const startTime = Date.now();
            
            try {
                showProgressIndicator('Testing Overpass API...');
                
                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: new URLSearchParams({ data: testQuery }),
                    signal: AbortSignal.timeout(15000)
                });
                
                const responseTime = Date.now() - startTime;
                
                if (response.ok) {
                    const osmData = await response.text();
                    const nodes = (osmData.match(/<node/g) || []).length;
                    const ways = (osmData.match(/<way/g) || []).length;
                    
                    const message = `✅ Overpass API Test Successful

⏱️ Response time: ${responseTime}ms
📊 Power infrastructure found:
  • ${nodes} power nodes
  • ${ways} power ways
📦 Data size: ${(osmData.length / 1024).toFixed(1)} KB

🎯 The API is responding normally.`;

                    alert(message);
                    toast.show('Overpass API test successful', 'success');
                } else {
                    const errorMsg = `❌ Overpass API Test Failed

❌ HTTP Error: ${response.status} ${response.statusText}
⏱️ Response time: ${responseTime}ms

The Overpass API may be temporarily unavailable.
Try again later or use JOSM's download feature.`;
                    
                    alert(errorMsg);
                    toast.show('Overpass API test failed', 'error');
                }
                
            } catch (error) {
                const responseTime = Date.now() - startTime;
                const errorMsg = `❌ Overpass API Test Failed

❌ Connection failed: ${error.message}
⏱️ Response time: ${responseTime}ms

Check your internet connection or try again later.`;
                
                alert(errorMsg);
                toast.show(`Overpass test failed: ${error.message}`, 'error');
            } finally {
                hideProgressIndicator();
            }
        }

        // Enhanced JOSM test for main page
        window.testJOSMButton = async function() {
            showProgressIndicator('Testing JOSM connection...');
            
            try {
                const result = await testJOSM();
                
                if (result.connected) {
                    const message = `✅ JOSM Connection Successful!

🔧 JOSM Version: ${result.version.application || 'Unknown'}
📡 Remote Control: Active
🌐 Port 8111: Accessible

🎯 Ready for patch loading!`;
                    
                    alert(message);
                    toast.show('JOSM connection verified', 'success');
                } else {
                    const message = `❌ JOSM Connection Failed

💡 Error: ${result.error}

🔧 Troubleshooting Steps:
1. Ensure JOSM is running
2. Enable remote control:
   Edit → Preferences → Remote Control
3. Check "Enable remote control"
4. Restart JOSM after enabling
5. Verify no firewall blocking port 8111
6. Try running JOSM as administrator

${result.help ? '\n💡 ' + result.help : ''}`;
                    
                    const openHelp = confirm(message + '\n\nOpen JOSM help documentation?');
                    if (openHelp) {
                        window.open('https://josm.openstreetmap.de/wiki/Help/Preferences/RemoteControl', '_blank');
                    }
                    
                    toast.show('JOSM connection failed', 'error');
                }
            } finally {
                hideProgressIndicator();
            }
        };
        
        // Enhanced debug function
        async function debugDatabase() {
            try {
                showProgressIndicator('Gathering debug information...');
                updateConnectionStatus(true, 'Querying...');
                
                // Comprehensive database statistics
                const countriesQuery = '/osmose_patches?select=country_code,country_name&limit=2000';
                const allPatches = await supabaseQuery(countriesQuery);
                
                // Enhanced statistics
                const countryCounts = {};
                const countryNames = {};
                allPatches.forEach(patch => {
                    const code = patch.country_code;
                    countryCounts[code] = (countryCounts[code] || 0) + 1;
                    if (patch.country_name) {
                        countryNames[code] = patch.country_name;
                    }
                });
                
                const topCountries = Object.entries(countryCounts)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 20);
                
                // Get completion statistics
                const completedQuery = '/patch_assignments?select=patch_id,status&status=eq.completed';
                const completedPatches = await supabaseQuery(completedQuery);
                
                // Recent activity
                const recentQuery = '/patch_assignments?select=mapper_id,completed_at&status=eq.completed&order=completed_at.desc&limit=10';
                const recentActivity = await supabaseQuery(recentQuery);
                
                // Sample patches with more details
                const sampleQuery = '/osmose_patches?select=patch_id,country_code,error_count,area_km2,priority,difficulty&limit=8';
                const samplePatches = await supabaseQuery(sampleQuery);
                
                let message = '🔍 Database Debug Information\n\n';
                
                message += `📊 Database Statistics:\n`;
                message += `  Total patches: ${allPatches.length.toLocaleString()}\n`;
                message += `  Completed patches: ${completedPatches.length.toLocaleString()}\n`;
                message += `  Completion rate: ${((completedPatches.length / allPatches.length) * 100).toFixed(1)}%\n\n`;
                
                if (topCountries.length > 0) {
                    message += '🌍 Top Countries with Patches:\n';
                    topCountries.forEach(([code, count]) => {
                        const name = countryNames[code] || code;
                        const percentage = ((count / allPatches.length) * 100).toFixed(1);
                        message += `  ${code} (${name}): ${count.toLocaleString()} patches (${percentage}%)\n`;
                    });
                }
                
                if (recentActivity.length > 0) {
                    message += '\n🚀 Recent Completions:\n';
                    recentActivity.slice(0, 5).forEach(activity => {
                        const date = new Date(activity.completed_at).toLocaleDateString();
                        message += `  ${activity.mapper_id} on ${date}\n`;
                    });
                }
                
                message += `\n🔧 Technical Information:\n`;
                message += `  Frontend version: 2.0.0 (Enhanced)\n`;
                message += `  API endpoint: ${CONFIG.SUPABASE_URL}\n`;
                message += `  Connection retries: ${CONFIG.MAX_RETRIES}\n`;
                message += `  Last refresh: ${new Date(AppState.lastRefresh).toLocaleTimeString()}\n`;
                message += `  Theme: ${AppState.theme}\n`;
                
                if (samplePatches.length > 0) {
                    message += '\n📝 Sample Patches:\n';
                    samplePatches.forEach(p => {
                        message += `  ${p.patch_id} (${p.country_code}): ${p.error_count || 0} errors, ${p.difficulty || 'Medium'} difficulty\n`;
                    });
                }
                
                alert(message);
                updateConnectionStatus(true);
                toast.show('Debug information collected', 'info');
                
            } catch (error) {
                console.error('Debug failed:', error);
                updateConnectionStatus(false, 'Debug Error');
                alert(`❌ Debug failed: ${error.message}\n\nCheck console for more details.`);
                toast.show(`Debug failed: ${error.message}`, 'error');
            } finally {
                hideProgressIndicator();
            }
        }

        // Enhanced keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            // Don't trigger shortcuts when typing in inputs
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
                return;
            }
            
            switch(event.key) {
                case 'Escape':
                    closeAllPatches();
                    break;
                case 'r':
                case 'R':
                    if (!AppState.isLoading) {
                        event.preventDefault();
                        loadPatches();
                    }
                    break;
                case 't':
                case 'T':
                    event.preventDefault();
                    testJOSMButton();
                    break;
                case '?':
                    event.preventDefault();
                    toggleKeyboardHelp();
                    break;
                case 'd':
                case 'D':
                    if (event.ctrlKey || event.metaKey) {
                        event.preventDefault();
                        themeManager.toggle();
                    }
                    break;
            }
        });

        function toggleKeyboardHelp() {
            const help = document.getElementById('keyboardHelp');
            help.style.display = help.style.display === 'block' ? 'none' : 'block';
        }

        // Enhanced initialization
        window.addEventListener('load', async () => {
            updateConnectionStatus(false, 'Connecting...');
            
            // Initialize theme
            themeManager.applyTheme(AppState.theme);
            
            // Set up theme toggle
            document.getElementById('themeToggle').addEventListener('click', () => {
                themeManager.toggle();
            });
            
            // Test initial connection with retry logic
            let connected = false;
            for (let attempt = 1; attempt <= 3 && !connected; attempt++) {
                connected = await testConnection();
                if (!connected && attempt < 3) {
                    logProgress(`Connection attempt ${attempt} failed, retrying...`, 'warning');
                    await new Promise(resolve => setTimeout(resolve, 2000 * attempt));
                }
            }
            
            if (connected) {
                loadPatches();
                toast.show('Application loaded successfully', 'success');
            } else {
                document.getElementById('patches').innerHTML = 
                    `<div class="error-state">
                        <div class="error-icon">❌</div>
                        <h3>Database connection failed</h3>
                        <p>Unable to connect after multiple attempts.</p>
                        <p>Please check your internet connection and try refreshing the page.</p>
                        <button onclick="window.location.reload()" class="button refresh-button">🔄 Reload Page</button>
                    </div>`;
                toast.show('Failed to connect to database', 'error');
            }
        });
        
        // Enhanced auto-refresh with exponential backoff
        let refreshInterval = CONFIG.REFRESH_INTERVAL;
        setInterval(() => {
            if (Date.now() - AppState.lastRefresh > refreshInterval && !AppState.isLoading) {
                if (AppState.connectionStatus === 'online') {
                    loadPatches();
                    refreshInterval = CONFIG.REFRESH_INTERVAL; // Reset interval on success
                } else {
                    refreshInterval = Math.min(refreshInterval * 1.5, 600000); // Max 10 minutes
                }
            }
        }, 60000);
        
        // Enhanced online/offline handling
        window.addEventListener('online', async () => {
            toast.show('Connection restored', 'success');
            await testConnection();
            if (AppState.connectionStatus === 'online') {
                loadPatches();
            }
        });

        window.addEventListener('offline', () => {
            updateConnectionStatus(false, 'No Internet');
            toast.show('Connection lost', 'warning');
        });

        // Service worker registration for offline support (optional)
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js').catch(err => {
                console.log('Service worker registration failed:', err);
            });
        }
    </script>
</body>
</html>